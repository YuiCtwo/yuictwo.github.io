<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ctwo&#39;s Blog</title>
  <icon>http://cyx0706.github.io/icon.png</icon>
  
  <link href="http://cyx0706.github.io/atom.xml" rel="self"/>
  
  <link href="http://cyx0706.github.io/"/>
  <updated>2025-05-08T09:04:36.377Z</updated>
  <id>http://cyx0706.github.io/</id>
  
  <author>
    <name>Ctwo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单文件 MongoDB 服务器（1）</title>
    <link href="http://cyx0706.github.io/2025/03/20/mongodb/"/>
    <id>http://cyx0706.github.io/2025/03/20/mongodb/</id>
    <published>2025-03-20T12:42:24.000Z</published>
    <updated>2025-05-08T09:04:36.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子">引子</h2><p><s>是的我找回了自己的博客</s></p><p>起因是我的小伙伴在假期提出了一个需求：</p><blockquote><p>在单个文件中存储数据，并使用 MongoDB 的方式来存取<br>还附上了已有开发者做的项目 <a href="https://github.com/schapman1974/tinymongo">TinyMongo</a><br>但上面这个项目，并不能使用现有的工具来进行连接（比如说 MongoDB Compass）<br>原因也很简单，项目只实现了一个 Client，并没有一个 Server 来与其他软件进行通信。</p></blockquote><p>我寻思，这个问题看起来不难~~（真的吗？）~~，而且我本身也对数据库服务器这块感兴趣，便开始着手研究和编写代码。<br>由于读写已经由别的项目完成了，所以我只需要专注于完成 “服务器” 应该干的事情。</p><p>那么，数据库服务器应该干什么呢？<br>不知道，没一点头绪，该死的本科水专业课，只会让人背 SQL 语句。<br>教程，貌似也没有完全面向小白的。<br>那就撸袖子干，写到哪里算哪里，等对问题有基本认知了再来回头重构代码，学习更优秀的设计，参考开源代码。<br>GO，GO，先搓起来先~</p><p>注意！！！<br>本人对数据库是完全的小白，该系列纯粹是为本人在学习过程中的记录，包括但不限于“我寻思应该这样写”。代码可能不美观，但我相信它会随着我对这个问题的掌握逐渐越来越好了。</p><p><s>希望哪天做 AI 失业了还能靠学习的这个吃口饭</s></p><p><strong>小目标是搭一个能跑起来的服务！不问性能</strong></p><span id="more"></span><p>MongoDB 基于 TCP 协议来实现通信，在 Python 里实现一个 TCP 服务器也很简单，基于 socket 库即可：</p><blockquote><p>Python 中的 socket 模块是用于实现网络通信的模块，提供了底层网络操作的接口，使得用户可以通过网络实现客户端和服务器之间的数据传输、连接和通信。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">server_socket.bind((host, port))</span><br><span class="line"><span class="comment"># set maximum number of connections</span></span><br><span class="line">server_socket.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># log server start</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Server started on <span class="subst">&#123;host&#125;</span>:<span class="subst">&#123;port&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>host, port 分别是地址和端口，例如<code>host=&quot;127.0.0.1&quot;, port=&quot;27019&quot;</code></p><p>MongoDB 官方文档给出了定义的通信格式 <a href="https://www.mongodb.com/zh-cn/docs/manual/reference/mongodb-wire-protocol/">mongodb-wire-protocol</a> 我只能说可读性很差的。<br>这里对它的内容进行简单的整理：</p><p>请求应包括<strong>消息头</strong>和<strong>请求有效负载</strong>，而响应则包括<strong>消息头</strong>和<strong>响应有效负载</strong></p><p>需要注意：</p><ul><li>请求和响应的有效负载并不相同</li><li>消息头和有效负载都是 BSON 格式的二进制数据</li><li>消息的排序遵循小端序（little-endian）</li></ul><p>而 BSON（Binary JSON）是一种二进制形式的 JSON 文档。它是 MongoDB 数据库的默认数据存储格式。</p><h2 id="消息头">消息头</h2><p>官方文档给出消息头的定义为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MsgHeader</span> &#123;</span></span><br><span class="line">    int32   messageLength; <span class="comment">// total message size, including this</span></span><br><span class="line">    int32   requestID;     <span class="comment">// identifier for this message</span></span><br><span class="line">    int32   responseTo;    <span class="comment">// requestID from the original request</span></span><br><span class="line">                           <span class="comment">//  (used in responses from the database)</span></span><br><span class="line">    int32   opCode;        <span class="comment">// message type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>messageLength：整个消息的大小，包括消息头</li><li>requestID：每个请求的唯一标识符，由客户端或数据库生成</li><li>responseTo：如果是响应，则为请求的 requestID；如果是请求，则为 0</li><li>opCode：消息类型，包括请求、响应、错误、通知等</li></ul><p>无论是请求还是响应，都要遵循该消息头来进行传输</p><h2 id="有效负载">有效负载</h2><p>这个就五花八门了，现在网上大部分的资料都是基于 5.1 版本的前的，对于 opCode 中的例如 <code>OP_QUERY</code>, <code>OP_INSERT</code>, <code>OP_QUERY</code> 等等都有很详尽的定义，详细的可以在旧版本的操作码中找到，至于新版，换成了统一的了。</p><p>从 5.1 版本开始，<code>OP_MSG</code> 和 <code>OP_COMPRESSED</code> 是向 Server 发送请求时唯一支持的操作码</p><p><code>OP_COMPRESSED</code> 是 5.1 版本的压缩请求，用于支持压缩数据。<code>OP_MSG</code> 是 5.1 版本的消息请求，用于支持多文档事务。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OP_MSG &#123;</span><br><span class="line">    MsgHeader header;           // standard message header</span><br><span class="line">    uint32 flagBits;            // message flags</span><br><span class="line">    Sections[] sections;        // data sections</span><br><span class="line">    optional&lt;uint32&gt; checksum;  // optional CRC-32C checksum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较关键的部分在于：flagBits 标志位和 sections 消息数组：</p><ul><li>flagBits: 前 16 位必须有，我个人的理解是只能设置有实际含义的二进制位，否则，解析器则必须报错，对应原文是 <code>&quot;The first 16 bits (0-15) are required and parsers MUST error if an unknown bit is set.&quot;</code><br>最后 16 位是可选的，允许设置一些额外的标志位，但代理和其他消息转发器必须在转发消息之前清除任何未知的可选位。</li></ul><p>sections 中可以包含单个的 BSON 对象，也可以包含一个文档。<br>文档是 MongoDB 的基本数据单元，使用 BSON 格式存储。一个文档包含了一组键值对，类似于 JSON 对象。<br>如： <code>&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30, &quot;city&quot;: &quot;New York&quot;&#125;</code></p><p>看完了，SO？首先作为客户端连接服务器要发什么请求？作为服务端返回的内容又包含了什么？</p><h2 id="握手请求">握手请求</h2><p>我们都知道和服务器建立连接前都要先尝试“握手”，即发送一些配置信息来确定双方后续沟通的一些细节。我姑且把这样的部分成为“握手阶段”。</p><p>客户端要和 MongoDB 的服务器建立通信，同样也会先发送一些类似测试的指令，然而，官方文档关于这方面写的极其少，并且隐藏的很深（不好找），那么很简单，抓包看官方客户端和服务端如何通信的即可。<br>我用的抓包工具是 WireShark，具体如何抓就不赘述了，直接贴有哪些请求的结论：</p><h3 id="isMaster">isMaster</h3><p>选择 MongoDB Compass 作为客户端（版本 &gt; 5.1），连接到 MongoDB Server。连接刚开始的时候会不断地尝试发送 <code>OP_QUERY</code> 请求。请求内容为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;flags&quot;: 0,</span><br><span class="line">    &quot;fullCollectionName&quot;: &quot;admin.$cmd&quot;,</span><br><span class="line">    &quot;numberToSkip&quot;: 0,</span><br><span class="line">    &quot;numberToReturn&quot;: -1,</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;ismaster&quot;: 1,</span><br><span class="line">        &quot;helloOk&quot;: True,</span><br><span class="line">        &quot;client&quot;: &#123;</span><br><span class="line">            &quot;application&quot;: &#123;</span><br><span class="line">                &quot;name&quot;: &quot;MongoDB Compass&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;driver&quot;: &#123;</span><br><span class="line">                &quot;name&quot;: &quot;nodejs&quot;,</span><br><span class="line">                &quot;version&quot;: &quot;6.12.0&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;platform&quot;: &quot;Node.js v20.18.1, LE&quot;,</span><br><span class="line">            &quot;os&quot;: &#123;</span><br><span class="line">                &quot;name&quot;: &quot;win32&quot;,</span><br><span class="line">                &quot;architecture&quot;: &quot;x64&quot;,</span><br><span class="line">                &quot;version&quot;: &quot;10.0.22631&quot;,</span><br><span class="line">                &quot;type&quot;: &quot;Windows_NT&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;compression&quot;: [&quot;none&quot;]</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;returnFieldsSelector&quot;: None</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我把请求的全部 payload 展示出来，方便查看。isMaster 请求是一个 <code>OP_QUERY</code> 类型的消息。<br>此事在官方文档中已有记载，虽然我们使用了新版本的 <code>OP_MSG</code>，但唯一支持的旧操作码就是这个 <code>OP_QUERY</code><br>我本人 MongoDB 的使用经验很少，很多命令一知半解，只能大致的猜测一些字段的含义。</p><p>当收到 <code>OP_QUERY</code> 的 “isMaster” 请求的回复后，会<strong>接着</strong>发送一个 <code>OP_MSG</code> 的版本</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x27;flagBits&#x27;: 65536,</span><br><span class="line">    &#x27;sections&#x27;: [&#123;</span><br><span class="line">        &#x27;hello&#x27;: 1,</span><br><span class="line">        &#x27;maxAwaitTimeMS&#x27;: 10000,</span><br><span class="line">        &#x27;topologyVersion&#x27;: &#123;</span><br><span class="line">            &#x27;processId&#x27;: ObjectId(&#x27;679f5fe50ab84b41447995a7&#x27;),</span><br><span class="line">            &#x27;counter&#x27;: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;$db&#x27;: &#x27;admin&#x27;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须要指出，topologyVersion 的 counter 的字段类型为 Long，不仔细就会当做 int 来处理了 -_-||</p><p><code>maxAwaitTimeMS</code> 貌似是客户端最大会等待服务器的响应时间，（后续实验出来）一旦超过这个时间，该请求就会重发</p><p><code>topologyVersion</code> 是一个我目前完全无法理解的东西，跳过。</p><p>当这个请求也被回复后，客户端发送另外一个 <code>OP_MSG</code> 请求：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x27;flagBits&#x27;: 0,</span><br><span class="line">    &#x27;sections&#x27;: [&#123;</span><br><span class="line">        &#x27;ping&#x27;: 1,</span><br><span class="line">        &#x27;lsid&#x27;: &#123;</span><br><span class="line">            &#x27;id&#x27;: Binary(b &#x27;\xad\x98\xeb\xe2\xa1\xf5G\xef\xbd\xcc\xde\x01H\xaeA\xa9&#x27;, 4)</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x27;$db&#x27;: &#x27;admin&#x27;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟据官方文档的说明：</p><blockquote><p>ping 命令是一个空操作，用于测试服务器是否在响应命令。即使服务器处于写锁定状态，此命令也会立即返回：<br>lsid 指定与该命令关联的会话的唯一 ID</p></blockquote><p>至此我个人认为 isMaster 请求全部完成，至于如何响应这些请求，我会在下一章介绍。<br>明面上，完成这些步骤后  MongoDB Compass 上已经弹出服务器连接成功的提示框了，但实际上在你主动操作前，客户端还有请求发出。</p><h3 id="aggregate">aggregate</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#x27;flagBits&#x27;: 0,</span><br><span class="line">&#x27;sections&#x27;: [&#123;</span><br><span class="line">&#x27;aggregate&#x27;: 1,</span><br><span class="line">&#x27;pipeline&#x27;: [&#123;</span><br><span class="line">&#x27;$currentOp&#x27;: &#123;</span><br><span class="line">&#x27;allUsers&#x27;: True,</span><br><span class="line">&#x27;idleConnections&#x27;: False,</span><br><span class="line">&#x27;truncateOps&#x27;: False</span><br><span class="line">&#125;</span><br><span class="line">&#125;],</span><br><span class="line">&#x27;cursor&#x27;: &#123;&#125;,</span><br><span class="line">&#x27;lsid&#x27;: &#123;</span><br><span class="line">&#x27;id&#x27;: Binary(b &#x27;\xcb\xf3\xe4\x99\xca|H\xe7\x9eqZ\xea&lt;k\xec\x91&#x27;, 4)</span><br><span class="line">&#125;,</span><br><span class="line">&#x27;$db&#x27;: &#x27;admin&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个相当复杂的命令，官网有<a href="https://www.mongodb.com/zh-cn/docs/manual/reference/operator/aggregation/currentOp/">解释</a>，顾名思义，是查看当然执行的命令的相关信息，更多的我暂时也不知道了。</p><h3 id="top-buildInfo-hostInfo">top &amp; buildInfo &amp; hostInfo</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#x27;flagBits&#x27;: 0,</span><br><span class="line">&#x27;sections&#x27;: [&#123;</span><br><span class="line">&#x27;top&#x27;: 1,</span><br><span class="line">&#x27;lsid&#x27;: &#123;</span><br><span class="line">&#x27;id&#x27;: Binary(b &#x27;l\xf3\xceRD\x08I\xf9\x8bV\x14\x91\x88aDL&#x27;, 4)</span><br><span class="line">&#125;,</span><br><span class="line">&#x27;$db&#x27;: &#x27;admin&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余的命令和，比如 buildInfo 和 top 类似，只不过 sections 中的 <code>'top': 1</code> 变成了 <code>'buildInfo': 1</code></p><p>像这样的命令有还有 dbStats 和 atlasVersion，推测是获取一些服务器配置信息的命令。</p><h3 id="getParameter">getParameter</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#x27;flagBits&#x27;: 0,</span><br><span class="line">&#x27;sections&#x27;: [&#123;</span><br><span class="line">&#x27;getParameter&#x27;: 1,</span><br><span class="line">        &#x27;featureCompatibilityVersion&#x27;: 1</span><br><span class="line">&#x27;lsid&#x27;: &#123;</span><br><span class="line">&#x27;id&#x27;: Binary(b &#x27;l\xf3\xceRD\x08I\xf9\x8bV\xa1\x99\x88aDL&#x27;, 4)</span><br><span class="line">&#125;,</span><br><span class="line">&#x27;$db&#x27;: &#x27;admin&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="connectionStatus">connectionStatus</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#x27;flagBits&#x27;: 0,</span><br><span class="line">&#x27;sections&#x27;: [&#123;</span><br><span class="line">&#x27;connectionStatus&#x27;: 1,</span><br><span class="line">        &#x27;showPrivileges&#x27;: True</span><br><span class="line">&#x27;lsid&#x27;: &#123;</span><br><span class="line">&#x27;id&#x27;: Binary(b &#x27;B\xfd2\xc0\x8c\xf8I\xc2\x84\x08):|\x9e\x95y&#x27;, 4)</span><br><span class="line">&#125;,</span><br><span class="line">&#x27;$db&#x27;: &#x27;admin&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="listDatabases">listDatabases</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&#x27;flagBits&#x27;: 0,</span><br><span class="line">&#x27;sections&#x27;: [&#123;</span><br><span class="line">&#x27;listDatabases&#x27;: 1,</span><br><span class="line">        &#x27;nameOnly&#x27;: True</span><br><span class="line">&#x27;lsid&#x27;: &#123;</span><br><span class="line">&#x27;id&#x27;: Binary(b&quot;V&#x27;\xe1\xcf\xe2mL&amp;\xbf`\xf0\x87\x13\xfd\xc3\xe6&quot;, 4)</span><br><span class="line">&#125;,</span><br><span class="line">&#x27;$db&#x27;: &#x27;admin&#x27;</span><br><span class="line">&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最符合名字的一集，从名字就能推断出是列出现在所有的表，并且由于有 <code>nameOnly</code> 所以只需要列出名字。</p><h2 id="响应">响应</h2><p>只从文档无法推测出究竟需要返回什么样子的字段，还好我们有抓包，可以以此结果来反推信息。<br>不过在那之前，我们要先在 Python 里完成一些基础协议数据结构的东西。</p><h3 id="BSON">BSON</h3><p>BSON（Binary JSON）是一种二进制形式的 JSON 文档。它是 MongoDB 数据库的默认数据存储格式。<br>如何序列化这样的数据，不需要我们来完成，Python 有 支持库 <code>bson</code><br>我们可以调用 <code>bson.encode()</code> 来将 Python 的字典变为 BSON 文档，同时使用 <code>bson.decode()</code> 将 BSON 文档转换为 Python 字典。<br>需要注意的是，Python 的 整数默认为 Int32，当我们需要用到 Int64 类型时，可以考虑使用 <code>bson.int64.Int64()</code></p><h3 id="消息头-2">消息头</h3><p>众所周知，对于 socket 获取的流数据，一般都是二进制，并且使用 socket 发送内容的时候也要用二进制。<br>Python 内置一个二进制数据处理的相关库 <code>struct</code>，通过使用 <code>struct.pack() | struct.unpack()</code> 可以快速将Python数据打包或者解包一个二进制数据，使用不同的“格式化字符串”可以指定打包成不同的二进制格式，比如说大小端，uint类型等等。详细的可以去查看使用文档。</p><p>要解包消息头，使用 <code>struct</code> 就非常的简单。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeadParser</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_decode</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="comment"># MongoDB message header</span></span><br><span class="line">        <span class="comment"># 16 bytes in total, 4 bytes each: (message length), (request id), (response to), (op code)</span></span><br><span class="line">        header = struct.unpack(<span class="string">&quot;&lt;iiii&quot;</span>, data[:<span class="number">16</span>])</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="string">&quot;message_length&quot;</span>: header[<span class="number">0</span>],</span><br><span class="line">            <span class="string">&quot;request_id&quot;</span>: header[<span class="number">1</span>],</span><br><span class="line">            <span class="string">&quot;response_to&quot;</span>: header[<span class="number">2</span>],</span><br><span class="line">            <span class="string">&quot;op_code&quot;</span>: header[<span class="number">3</span>]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>而有效负载，不同的有不同的格式，<br>我们先搓几个工具函数，它从二进制数据流中读取特定的 Python 数据。更具体的实现可以移步到该项目我的 Github 仓库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byte2string</span>(<span class="params">data, offset</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Convert byte data to string.</span></span><br><span class="line"><span class="string">    :param data: byte data</span></span><br><span class="line"><span class="string">    :param offset: pointer to the start of the string</span></span><br><span class="line"><span class="string">    :return: pointer to the end of the string and the string</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    full_str = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="comment"># cstring end with b&#x27;\0&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> data[offset] != <span class="number">0</span>:</span><br><span class="line">        full_str += <span class="built_in">chr</span>(data[offset])</span><br><span class="line">        offset += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> offset+<span class="number">1</span>, full_str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byte2int32</span>(<span class="params">data, offset</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Convert byte data to integer.</span></span><br><span class="line"><span class="string">    :param data: byte data</span></span><br><span class="line"><span class="string">    :param offset: pointer to the start of the integer</span></span><br><span class="line"><span class="string">    :return: pointer to the end of the integer and the integer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    integer = struct.unpack(<span class="string">&quot;&lt;i&quot;</span>, data[offset:offset+<span class="number">4</span>])[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> offset+<span class="number">4</span>, integer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byte2int64</span>(<span class="params">data, offset</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Convert byte data to integer.</span></span><br><span class="line"><span class="string">    :param data: byte data</span></span><br><span class="line"><span class="string">    :param offset: pointer to the start of the integer</span></span><br><span class="line"><span class="string">    :return: pointer to the end of the integer and the integer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    integer = struct.unpack(<span class="string">&quot;&lt;q&quot;</span>, data[offset:offset+<span class="number">8</span>])[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> offset+<span class="number">8</span>, integer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byte2document</span>(<span class="params">data, offset</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Covert byte data to dict object in Python</span></span><br><span class="line"><span class="string">    :param data: byte data</span></span><br><span class="line"><span class="string">    :param offset: pointer to the start of the document</span></span><br><span class="line"><span class="string">    :return: offset and decoded document result</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    doc_length = struct.unpack(<span class="string">&quot;&lt;i&quot;</span>, data[offset: offset+<span class="number">4</span>])[<span class="number">0</span>]</span><br><span class="line">    document = bson.decode(data[offset: offset+doc_length])</span><br><span class="line">    offset += doc_length</span><br><span class="line">    <span class="keyword">return</span> offset, document</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byte2uint32</span>(<span class="params">data, offset</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Convert byte data to unsigned integer.</span></span><br><span class="line"><span class="string">    :param data: byte data</span></span><br><span class="line"><span class="string">    :param offset: pointer to the start of the integer</span></span><br><span class="line"><span class="string">    :return: pointer to the end of the integer and the integer</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    integer = struct.unpack(<span class="string">&quot;&lt;I&quot;</span>, data[offset:offset+<span class="number">4</span>])[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> offset+<span class="number">4</span>, integer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">byte2sections</span>(<span class="params">data, offset</span>):</span></span><br><span class="line">    current_offset = offset</span><br><span class="line">    current_offset, section_size = byte2int32(data, current_offset)</span><br><span class="line">    section_name = byte2string(data, current_offset)</span><br><span class="line">    documents = []</span><br><span class="line">    <span class="keyword">while</span> current_offset &lt; offset + section_size:</span><br><span class="line">        current_offset, document = byte2document(data, current_offset)</span><br><span class="line">        documents.append(document)</span><br><span class="line">    res = &#123;</span><br><span class="line">        section_name: documents</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current_offset, res</span><br></pre></td></tr></table></figure><h3 id="CRC-校验">CRC 校验</h3><p>不算太难，内置库 <code>zlib</code> 有现成的轮子调用，直接给出实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">crc32_checksum</span>(<span class="params">raw_data, checksum</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Calculate the CRC32 checksum of the given data and compare it with the given checksum.</span></span><br><span class="line"><span class="string">    :param raw_data: Total data except the checksum</span></span><br><span class="line"><span class="string">    :param checksum: The expected checksum</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    computed_checksum = zlib.crc32(raw_data) &amp; <span class="number">0xFFFFFFFF</span></span><br><span class="line">    <span class="keyword">return</span> computed_checksum == checksum</span><br></pre></td></tr></table></figure><p>有了这些基本的认知还有工具，下一节我们来实现一个应答这些请求的服务器。<s>里面也有很多坑</s></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;引子&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;是的我找回了自己的博客&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;起因是我的小伙伴在假期提出了一个需求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在单个文件中存储数据，并使用 MongoDB 的方式来存取&lt;br&gt;
还附上了已有开发者做的项目 &lt;a href=&quot;https://github.com/schapman1974/tinymongo&quot;&gt;TinyMongo&lt;/a&gt;&lt;br&gt;
但上面这个项目，并不能使用现有的工具来进行连接（比如说 MongoDB Compass）&lt;br&gt;
原因也很简单，项目只实现了一个 Client，并没有一个 Server 来与其他软件进行通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我寻思，这个问题看起来不难~~（真的吗？）~~，而且我本身也对数据库服务器这块感兴趣，便开始着手研究和编写代码。&lt;br&gt;
由于读写已经由别的项目完成了，所以我只需要专注于完成 “服务器” 应该干的事情。&lt;/p&gt;
&lt;p&gt;那么，数据库服务器应该干什么呢？&lt;br&gt;
不知道，没一点头绪，该死的本科水专业课，只会让人背 SQL 语句。&lt;br&gt;
教程，貌似也没有完全面向小白的。&lt;br&gt;
那就撸袖子干，写到哪里算哪里，等对问题有基本认知了再来回头重构代码，学习更优秀的设计，参考开源代码。&lt;br&gt;
GO，GO，先搓起来先~&lt;/p&gt;
&lt;p&gt;注意！！！&lt;br&gt;
本人对数据库是完全的小白，该系列纯粹是为本人在学习过程中的记录，包括但不限于“我寻思应该这样写”。代码可能不美观，但我相信它会随着我对这个问题的掌握逐渐越来越好了。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;希望哪天做 AI 失业了还能靠学习的这个吃口饭&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;小目标是搭一个能跑起来的服务！不问性能&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="database" scheme="http://cyx0706.github.io/categories/database/"/>
    
    
    <category term="mongodb" scheme="http://cyx0706.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>走出疫情，走出个人阴影</title>
    <link href="http://cyx0706.github.io/2023/05/31/hello-scientific-research/"/>
    <id>http://cyx0706.github.io/2023/05/31/hello-scientific-research/</id>
    <published>2023-05-31T03:22:19.000Z</published>
    <updated>2023-05-31T03:45:08.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>鸽了快一年（<s>酝酿了一年</s>） 想起来有些东西可以写一写，姑且写给曾经的自己吧</p></blockquote><h2 id="I">I</h2><p>个人心情沮丧的时候，再看那些王道热血的作品。在被人为划分的不同篇章里，小队的成员迫不得已面对自己的心魔，曾经内心的阴影和创伤。在篇章结束的时候，战胜了曾经的心理阴影，回到了吵吵闹闹的日常，成为值得信赖的伙伴。我们把这样的变化称为人物的成长，消除了内心的迷惘后更加团结的小队最终战胜了大魔王。</p><p>在疫情期间，我的低谷。我喜欢上了那些王道热血的作品</p><h2 id="II">II</h2><p>走上正轨？</p><h2 id="III">III</h2><p>一点点未来的希望</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;鸽了快一年（&lt;s&gt;酝酿了一年&lt;/s&gt;） 想起来有些东西可以写一写，姑且写给曾经的自己吧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;I&quot;&gt;I&lt;/h2&gt;
&lt;p&gt;个人心情沮丧的时候，再看那些王道热血的作品。在被人为划分的不同篇章里，小队的成员迫</summary>
      
    
    
    
    
    <category term="essay" scheme="http://cyx0706.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>乘海行远，奋楫扬帆</title>
    <link href="http://cyx0706.github.io/2022/08/04/hello-master-program/"/>
    <id>http://cyx0706.github.io/2022/08/04/hello-master-program/</id>
    <published>2022-08-04T01:49:19.000Z</published>
    <updated>2022-10-27T10:25:31.435Z</updated>
    
    <content type="html"><![CDATA[<ul><li><strong>2022/10/27 更新了毕设体验研究生生活的部分。</strong></li></ul><hr><p><s>实验室的电脑 g 了，变得无所事事了，想起来还有点东西可以写。</s></p><blockquote><p>在解开心结后，“SSS” 的毕业典礼也到来了…在高中的时候还体会不到 AB 成员毕业仪式的意义，在参加过授予学士学位的毕业典礼后才明白过来那种感动和释然。</p></blockquote><p>这个夏天，我拿到学士学位毕业，也收到了研究生录取通知书。姑且在这样一个小的站牌处小憩一下，留下些记录。标题取自毕业歌会的送给我们祝语，寓意着我们从母校海洋大学离开去向远方，同时也不要忘记努力拼搏。</p><a id="more"></a><h2 id="I">I</h2><p>关于我的本科生活，我或多或少都在<a href="/2021/09/23/abaaba/">这篇</a>里面提到了。</p><p>在临近毕业之际，班级拍合照的时候，想起自己竟然认不全全部人，想起有几次班级活动特立独行的不参加，想起自己对班级班委选举的嗤之以鼻，突然有一丝丝伤感。我的宿舍在和计算机不同的一栋楼，因为这样的原因和班里的同学平时交流的很少，庆幸和 AiDai 在一层，有时晚上就会去拜访。白天的空闲时间我大都在社团里呆着，和班里同学的感情自然也就难免淡了不少。我想起在大一原专业自我介绍的班会上，热情和同班同学交流的我也变成了在大多数场合沉默寡言的样子。大概是天性使然吧。</p><p>毕业季，是离别。“西出阳关无故人”，我们都去往不同的城市，还有多少熟悉的人陪伴在身边？天下没有不散的筵席，班级的最后一餐的时候不少同学都放开手脚的喝酒，吵吵闹闹，这样的场景也就只有在毕业季的限定时节能看到。古代文人们以酒送行，千里送行，虽然时代不同，但我还是深切的感受到了一句句玩笑背后大家的不舍。越成长就会越孤独，孩童时候玩陀螺，打弹珠的朋友早已不知去向；初高中的微信群许久没有人说话；现在大学的朋友们也将纷纷离校，工作的工作，读研的读研，纵使留下了联系方式，可是以后用到的机会究竟还有多少？</p><p><img src="https://s2.loli.net/2022/08/04/y5Cs8hEjR7c2bHl.jpg" alt="如同秒速五厘米的男女主角一样，随着成长曾经不谋而合的人渐行渐远"></p><h2 id="II">II</h2><blockquote><p>你问我中国海洋大学计算机学院怎么样，我会告诉你她离顶尖高校还很远，无论是专业还是硬件设施，学校本身也没有响亮的名号。但你要愿意放下偏见，人上人的心态，我会自豪的介绍我的母校，说她樱花大道的飞樱，每几步都有人驻足欣赏，亦或是拍照；说她海纳百川的校训；说她秋冬时节逃不过的妖风；说她五子顶上俯瞰的风景。我会说，我感恩我的母校，我热爱她。</p></blockquote><p>这段话在我手机的备忘录里躺了很久，是和曾经的同学见面，聚会几次后写下的。</p><p>在和小学初高中同学们，父母的同事，朋友的父母聊起来学校时，我提及中国海洋大学，在看到他们一脸迷茫后总会在后面接一句 985 高校。打听曾经高中同学的出路，亦或是在同学聚餐的时候，听到他们响亮的学校名号，总难免不了心理产生丝丝自卑，不愿意提及大学学校，生怕他们会想“当年成绩好的 xxx 也不过如此嘛”。羡慕着他们轻松的保研本校，也羡慕他们有对象。知道我是读研后，父亲的同事总会夸我一两句：孩子学习挺好的啊，似乎他们还没有感觉到读研热潮，也并不明白大学的成绩有不少和学习能力并不相关。我有几个朋友二战了，我也感受到了逐年增加的考研压力，也难怪刚入学时学长就告诉我们争取保研，如果没有大一当初拼绩点，还不知道现在会是什么样子。</p><h2 id="III">III</h2><p>青岛是个好城市，人们都很友善，坐地铁不用太久就可以去奥帆中心看海，或者去石老人附近吹吹海风。海大新校区定在了黄岛，有幸和社团的朋友们一起参观了新校区，出校门不久就是一片海和沙滩。宿舍楼就在海旁边，称得上是海景房，说不定每天晚上都能听着海浪声入眠。</p><p>小的时候曾经去看过还，不过只留下了坐船晕船的不适感。而现在随着成长，也越来越喜欢看海，夜幕降临的时候，就踏着海水吹着海风。耳畔传来海水拍打在礁石上的声音，混着淡淡的腥咸气。这时候我可以俯身鞠起一捧海水。离开了城市的灯红酒绿，抬头是星河，在世俗喧嚣的一隅还有这样安静的地方，仿佛是日渐功利焦虑的我内心中还保留着的温润纯良，最初的样子。</p><p>趁疫情的空隙，去南京旅游了一圈，体会了古城的人文气息，回忆了故居和陵园遗留下的历史，也观赏了南方小桥流水园林的自然风光。以后闲暇时做一个背起行囊旅游的人也不错，不是囫囵吞枣的打卡式参观，而是仔细品味人文和自然的拜访，听一听老房子，老巷它们的故事，在只言片语的诗歌，历史故事中窥见过去。</p><div align="center"><img src="https://s2.loli.net/2022/08/04/hCKMQfodkHR9JA1.jpg" alt="大连的海，网上的图" style="zoom:50%;" width=80%/></div><h2 id="IV">IV</h2><p>曾在大四下学期前往课题组做毕设，出发的时候，意气风发，信心满满，为自己能在国内最优秀的课题组之一学习和科研感到骄傲。</p><p>刚起步的日子有些辛苦，花了几天时间重装实验室电脑系统，和显卡驱动斗智斗勇，配环境，当总算大功告成的时候，学校封校了。像满腔热血被人泼了冷水，我做梦也没想到“线上”的日子离我这么近。</p><p>最初的时间浑浑噩噩，每天晚睡晚起，一日两顿甚至一顿饭，陌生的城市，只有我一个人住的屋子，心情失落的时候总是埋怨自己为什么要去校外做毕设折腾自己，有时难得的好心情也随即因为对自己碌碌无为的内疚而消散。</p><p>毕设还是要做，纵使内心抗拒，还是用上了远程连接软件向日葵，时不时享受着超高延时写代码带来的苦涩。这段时间偶尔小区会封控，就买了口锅自己尝试做点饭糊口。第一次体验这种管控的生活竟有一丝丝乐趣，早上起来做核酸，回来做顿早饭，吃完想想思路看看论文，午饭吃完休息会，下午看看谢谢代码办办杂事，晚上就在小区内遛弯。尝试熟悉这样的生活消耗了我大量的精力，对新知识的学习和兴趣都降到了最低。在居家一个多月的时候终于回到了学校，配好了 VSCode 和 PyCharm 远程开发后，为了逃避未来可能这样的生活，逃避孤独感，以答辩为理由急匆匆的赶回了本科学校。我觉得我毕设做得一塌糊涂，这一趟校外毕设之旅，从准备到结束也是一塌糊涂。</p><div align="center"><img src="https://s2.loli.net/2022/10/27/bHYE4LPVscSk8om.jpg" alt="喉咙捅完捅鼻子" style="zoom: 50%;" width=40%/></div><p>毕业很顺利，毕设答辩水到让我奶奶来都能过。回到熟悉的社团，吃到准时供应的食堂伙食，之前的焦虑完全消失，实验室的项目也进展顺利，学长觉得我进度太快一度劝我不要有太大压力，我笑着告诉学长我每天的生活很规律，就这样在轻松愉快中度过了最后的一个月。</p><h2 id="V">V</h2><p>有时我在想，什么才算独立，什么才算长大。总以为自己是顶天立地的好男儿，对各种问题都能轻松应对，憧憬过轻小说中“父母双忙，有妹有房”的主人公，豪言壮语：吾可取而代之！到头来自己完全是个娇生惯养的学生。不善于处理突发情况，不会调节自己的心情，不会规律作息和调节。在面临学业和生活的双重压力下这些平时无所谓的小毛病都严重影响了个人生活甚至身体健康。</p><p>研究生生活，我先写下一个 “成为能一个人独立生活的成年人”吧，希望自己在未来可以不再害怕孤独，学会调节自己，不再苦恼一个人的生活。</p><p>ps：研究生开学后又让封外面了 😡 ，不过这些都是后话了。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;2022/10/27 更新了毕设体验研究生生活的部分。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;s&gt;实验室的电脑 g 了，变得无所事事了，想起来还有点东西可以写。&lt;/s&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在解开心结后，“SSS” 的毕业典礼也到来了…在高中的时候还体会不到 AB 成员毕业仪式的意义，在参加过授予学士学位的毕业典礼后才明白过来那种感动和释然。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个夏天，我拿到学士学位毕业，也收到了研究生录取通知书。姑且在这样一个小的站牌处小憩一下，留下些记录。标题取自毕业歌会的送给我们祝语，寓意着我们从母校海洋大学离开去向远方，同时也不要忘记努力拼搏。&lt;/p&gt;</summary>
    
    
    
    
    <category term="essay" scheme="http://cyx0706.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理</title>
    <link href="http://cyx0706.github.io/2022/05/16/dip5/"/>
    <id>http://cyx0706.github.io/2022/05/16/dip5/</id>
    <published>2022-05-16T13:02:03.000Z</published>
    <updated>2022-05-17T02:41:35.599Z</updated>
    
    <content type="html"><![CDATA[<p>本篇包括以下算法的原理部分：</p><ul><li>简单线性迭代聚类（SLIC）</li></ul><a id="more"></a><h2 id="SLIC">SLIC</h2><p>代码详见 <a href="https://github.com/YuiCtwo/Learn-DIP">Learn-DIP</a> 仓库中对应的文件。</p><p>除了使用一般的聚类算法（如 K-Means）分割图像外，使用超像素进行区域分割也是常用的算法。<br>超像素的思想是，通过将像素组合到比各个像素更有感知意义的原始区域来取代标准的像素网格，主要目的是减少计算的开销，并通过减少不相关的细节来提高分割算法的性能。</p><p>超像素就是要用很少的像素来表示一张图片，但超像素表示的一个重要的需求就是对边界的附着性，在超像素图像中，必须保持我们感兴趣的区域，也就是不同显著的前景区域直接有明确的边界，不然就会影响我们对图片内内容的理解。</p><p>在超像素领域比较经典的算法就是 <strong>简单线性迭代聚类（SLIC）</strong> 法。SLIC 观测通常使用颜色量和空间坐标构成的 5 维向量作为计算的单元。以 RGB 颜色空间为例：</p><p style="text-align:center;transform:scale(0.85)"><img src="https://math.now.sh?from=%5Cmathcal%7Bz%7D%20%3D%20%5Cbegin%7Bbmatrix%7D%0Ar%20%5C%5C%0Ag%20%5C%5C%0Ab%20%5C%5C%20%0Ax%20%5C%5C%20%0Ay%0A%5Cend%7Bbmatrix%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%28r%2C%20g%2C%20b%29" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 表示像素的三个颜色分量，<img src="https://math.now.sh?inline=%28x%2C%20y%29" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 则是像素的空间坐标。令 <img src="https://math.now.sh?inline=n" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 表示所需要的像素总数。则初始化超像素中心 <img src="https://math.now.sh?inline=m_i%3B%20i%3D1%2C2%2C...n" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 为对图像以间距 <img src="https://math.now.sh?inline=s" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 单位的规则网络取样得到。初始的聚类中心要移动到每个中心周围 3x3 邻域的最小梯度位置，后续通过多步计算优化该位置，具体的算法如下：</p><ol><li>初始化：以规则网络步长 <img src="https://math.now.sh?inline=s" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 对图像取样，计算初始的超像素聚类中心 <img src="https://math.now.sh?inline=m_i" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/>。将聚类的中心移动至 3x3 邻域中最小梯度的位置，对于图像中每个像素位置 <img src="https://math.now.sh?inline=p" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/>，设置标签 <img src="https://math.now.sh?inline=L%28p%29%3D-1" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 和距离 <img src="https://math.now.sh?inline=d%28p%29%3D%5Cinf" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/>。</li><li>将样本分配给聚类中心：对于每个聚类中心 <img src="https://math.now.sh?inline=m_i" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/>。在一个关于 <img src="https://math.now.sh?inline=m_i" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 的 2sx2s 邻域中，计算 <img src="https://math.now.sh?inline=m_i" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 与每个像素 <img src="https://math.now.sh?inline=p" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 之间的距离 <img src="https://math.now.sh?inline=D_i%28p%29" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/>，然后对于每个 <img src="https://math.now.sh?inline=p" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/>，若 <img src="https://math.now.sh?inline=D_i%20%5Clt%20d%28p%29" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/>，则令 <img src="https://math.now.sh?inline=d%28p%29%3DD_i" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=L%28p%29%3Di" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/>。</li><li>更新聚类中心：令 <img src="https://math.now.sh?inline=C_i" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 表示图像中具有标记 <img src="https://math.now.sh?inline=L%28p%29%3Di" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 的像素集，更新 <img src="https://math.now.sh?inline=m_i" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/>，</li></ol><p style="text-align:center;transform:scale(0.85)"><img src="https://math.now.sh?from=m_i%20%3D%20%5Cfrac%7B1%7D%7B%7CC_i%7C%7D%5Csum_%7Bz%20%5Cin%20C_i%7D%5Cmathcal%7Bz%7D%2C%5Cquad%20i%3D1%2C2%2C...n%0A" /></p><p>其中 <img src="https://math.now.sh?inline=%7CC_i%7C" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 是集合 <img src="https://math.now.sh?inline=C_i" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 中的像素数，<img src="https://math.now.sh?inline=%5Cmathcal%7Bz%7D" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 和前面的表示一致。</p><ol start="4"><li>收敛性计算：计算当前步骤和前述步骤中平均向量之间的差的欧几里得范数。计算残差，当小于某个值时，停止循环。否则回到步骤 2。</li><li>后处理超像素区域：将每个区域 <img src="https://math.now.sh?inline=C_i" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 中的所有像素替换成他们的平均值 <img src="https://math.now.sh?inline=m_i" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/></li></ol><p>伪代码的表述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;∗ Initialization ∗&#x2F;</span><br><span class="line">Initialize cluster centers Ck &#x3D; [lk , ak , bk , xk , yk ]T by sampling pixels at regular grid steps S.</span><br><span class="line">Move cluster centers to the lowest gradient position in a 3 × 3 neighborhood.</span><br><span class="line">Set label l(i) &#x3D; −1 for each pixel i. Set distance d(i) &#x3D; ∞ for each pixel i.</span><br><span class="line"> </span><br><span class="line">repeat</span><br><span class="line">&#x2F;∗ Assignment ∗&#x2F;</span><br><span class="line">for each cluster center Ck do</span><br><span class="line">    for each pixel i in a 2S × 2S region around Ck do </span><br><span class="line">        Compute the distance D between Ck and i.</span><br><span class="line">        if D &lt; d(i) then</span><br><span class="line">            set d(i) &#x3D; D</span><br><span class="line">            set l(i) &#x3D; k </span><br><span class="line">        end if</span><br><span class="line">    end for </span><br><span class="line">end for</span><br><span class="line"> </span><br><span class="line">&#x2F;∗ Update ∗&#x2F;</span><br><span class="line">Compute new cluster centers. Compute residual error E.</span><br><span class="line">until E ≤ threshold</span><br></pre></td></tr></table></figure><p>关于其中距离 <img src="https://math.now.sh?inline=D%28p%29" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 的计算，有很多种方法，下面介绍一种经典的距离计算方法：由于我们使用的单元是像素点空间和颜色的集合，直接使用欧式距离是没有意义的，因为不同的坐标系的轴尺度不同，并且是不相关的。所以空间和颜色距离必须分开处理。</p><p style="text-align:center;transform:scale(0.85)"><img src="https://math.now.sh?from=%5Cbegin%7Beqnarray%7D%0Ad_c%20%26%20%3D%20%26%20%5B%28r_j-r_i%29%5E2%2B(g_j-g_i)%5E2%2B(b_j-b_i)%5E2%5D%5E%7B1%2F2%7D%20%5C%5C%0Ad_s%20%26%20%3D%20%26%20%5B(x_j-x_i)%5E2%2B(y_j-y_i)%5E2%5D%5E%7B1%2F2%7D%20%5C%5C%0AD%20%26%20%3D%20%26%20%5B(d_c%2Fd_%7Bcm%7D)%5E2%2B(d_s%2Fd_%7Bsm%7D)%5E2%5D%5E%7B1%2F2%7D%0A%5Cend%7Beqnarray%7D%0A" /></p><p>其中 <img src="https://math.now.sh?inline=d_%7Bcm%7D" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 和 <img src="https://math.now.sh?inline=d_%7Bsm%7D" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 是 <img src="https://math.now.sh?inline=d_c%2C%20d_s" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 的最大期望。最大空间距离应对应于取样间隔，即<img src="https://math.now.sh?inline=d_%7Bsm%7D%3Ds" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 而通常 <img src="https://math.now.sh?inline=d_%7Bcm%7D" style="text-align:center;transform:scale(0.85)display:inline-block;margin: 0;"/> 会被设置为一个常数。</p><h2 id="参考资料">参考资料</h2><ul><li>《数字图像处理》</li><li><a href="https://infoscience.epfl.ch/record/177415">SLIC Superpixels Compared to State-of-the-art Superpixel Methods</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇包括以下算法的原理部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简单线性迭代聚类（SLIC）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Digital Image Processing" scheme="http://cyx0706.github.io/categories/Digital-Image-Processing/"/>
    
    
    <category term="CV" scheme="http://cyx0706.github.io/tags/CV/"/>
    
    <category term="Digital Image Processing" scheme="http://cyx0706.github.io/tags/Digital-Image-Processing/"/>
    
  </entry>
  
  <entry>
    <title>数字图像处理</title>
    <link href="http://cyx0706.github.io/2022/04/05/dip4/"/>
    <id>http://cyx0706.github.io/2022/04/05/dip4/</id>
    <published>2022-04-05T07:49:40.000Z</published>
    <updated>2022-05-08T09:15:00.420Z</updated>
    
    <content type="html"><![CDATA[<p>Github 的 <code>README.md</code> 并不支持公式的渲染，所以部分原理讲解的东西移到这个篇章的博客中。</p><p>本篇包含：</p><ul><li>骨架提取</li><li>霍夫变换</li><li>Canny 边缘检测</li><li>Metric Rectification</li></ul><a id="more"></a><h2 id="Skeleton"><a href="#Skeleton" class="headerlink" title="Skeleton"></a>Skeleton</h2><p>前一段时间在看折痕消除的一篇论文的时候提到了提取文字的骨架，就重新复习一下《数字图像处理》这本书中关于骨架的知识。</p><p>集合 $A$ 的骨架的 $S(A)$ 概念上很简单：</p><p><strong>若 $z$ 是 $S(A)$ 的一点，$D_z$ 是 $A$ 内以 $z$ 为圆心的最大圆盘，则不存在包含 $D_z$ 且位于 $A$ 内的更大圆盘，满足这些条件的圆盘 $D_z$ 称为最大圆盘</strong></p><p>若 $D_z$ 是一个最大圆盘，则它在两个或多个不同的位置与 $A$ 的边界接触。</p><p><img src="https://i.loli.net/2021/09/29/wFeBZCoqPLaklJW.png" style="zoom: 25%;width: 50%" /></p><p>$A$ 的骨架可以用腐蚀和开运算来表示：</p><script type="math/tex; mode=display">S(A) = \bigcup_{k=0}^{K}S_k(A)= \bigcup_{k=0}^{K}(A\ominus kB)-(A\ominus kB)\circ B</script><p>式中，$B$ 是一个结构元，$A\ominus kB$ 表示 $A$ 的连续 $k$ 次腐蚀，同时，$K$ 是 $A$ 被腐蚀为一个空集前的最后一个迭代步骤：</p><script type="math/tex; mode=display">K = max\{ k| A\ominus kB \ne \oslash \}</script><h2 id="Canny"><a href="#Canny" class="headerlink" title="Canny"></a>Canny</h2><p>只使用梯度做边缘检测的一个很大的问题是：对噪声过于敏感，所以提出了 Canny 边缘检测算子。</p><p>Canny 算法基于以下三个目标：</p><ul><li><strong>低错误率</strong>：所有边缘都应该被找到，并且不应有虚假响应。</li><li><strong>边缘点应该被很好的定位</strong>：已定位的边缘必须尽可能接近真实边缘，也就是说，由检测子标记为边缘的一点和真实边缘的中心之间的距离应最小。</li><li><strong>单个边缘点响应</strong>：对于每个真实的边缘点，监测子应该只返回一个点，也就是说，真实边缘周围的局部最大数应该是最小的，这意味着检测子不应识别只存在单个边缘的多个边缘像素。</li></ul><p>与之对应的，Canny 边缘检测包含 5 个步骤：</p><ul><li>平滑（Suppress noise）</li><li>梯度计算（Compute gradient magnitude and direction）</li><li>非最大值抑制（Apply non-maximum suppression）</li><li>滞后阈值法/双阈值法（Hysteresis thresholding/Double thresholding）</li><li>连通性分析（Connectivity analysis to detect edges）</li></ul><p>首先采用高斯模糊来平滑图像。令 $f(x, y)$ 表示输入图像，并令 $G(x, y)$ 表示高斯函数：</p><script type="math/tex; mode=display">G(x, y) = e^{-\frac{x^2+y^2}{2 \sigma^2}}</script><p>用 G 和 f 的卷积得到平滑后的图像 $f_s(x, y)$</p><p>在这之后计算梯度幅度和方向：</p><script type="math/tex; mode=display">M_s(x, y) = || \nabla f_s(x, y) || = \sqrt{g_x^2(x,y)+g_y^2(x, y)} \\\alpha(x, y)=\mathrm {arctan} \left [ \frac{g_y(x,y)}{g_x(x,y)} \right ]</script><p>由于梯度图像通常在局部极大值附近包含一些宽脊，下一步非极大值抑制就是细化这些宽脊。</p><p>我们首先将所有可能的边缘方向量化为 4 个方向范围，如 0,45,90,135 如果该点处梯度的幅值小于该方向上的相邻两个点（在该点两侧），则抑制（赋值为 0），否则不变。</p><p>得到的图像 $g_N(x,y)$ 是只包含细化边缘的结果，然后我们对 $g_N(x,y)$ 进行阈值处理，以减少假边缘点。 Canny 算法使用滞后阈值处理，一个高阈值 $T_H$ 和一个低阈值 $T_L$。高低阈值的比率应该在 2 到 3 之间。</p><p>阈值运算可以看做创建了两个新的图像 $g_{NH}$ 和 $g_{NL}$</p><script type="math/tex; mode=display">g_{NH}(x,y)=g_N(x,y) \ge T_H \\g_{NL}(x,y)= T_H \gt g_N(x,y) \ge T_L</script><p>这两个分别代表“强”边缘像素和“弱”边缘像素，所有的强边界像素均被假设为有效的边缘像素，并被立即标记，如果弱边缘的像素连接到了强边缘（8邻域），则这些弱边缘也被认为是图像的边界，所以最后一步就是用BFS 判断一遍弱边缘是不是连接到了强边缘，如果连接到了，该点也可以认为是强边缘，就从该点继续向 8 邻域搜索。</p><h2 id="Hough-Transform"><a href="#Hough-Transform" class="headerlink" title="Hough Transform"></a>Hough Transform</h2><p>已知一副图像中的 n 个点，假设我们希望找到这些点中位于直线上的子集，一种可能的解决方法是。首先找到由每对点确定的直线，然后寻找特定直线的哪些点的所有子集。这种方法涉及寻找 $\frac{n(n-1)}{2}\sim n^2$ 条直线，然后将每个直线执行 $n*\frac{n(n-1)}{2}\sim n^3$ 次比较，计算困难。</p><p>Hough 提出了一种方法，通常称为霍夫变换。令 $(x_i, y_i)$ 表示 $xy$ 平面上的一点。并考虑一条直线的斜截式：</p><script type="math/tex; mode=display">y_i=a x_i +b</script><p>满足过点 $(x_i, y_i)$ 的直线有无数条，此时我们考虑 $ab$ 平面，并将直线改写成为：</p><script type="math/tex; mode=display">b=-x_i a +y_i</script><p>在该空间下，通过原直线的两个点 $(x_i, y_i), (x_j, y_j)$ 一定在某个点相交，这个点就是直线的斜率和截距。事实上，直线上的所有的点在该平面上都相交于一个点。</p><p><img src="https://i.loli.net/2021/10/09/W3JhNH7p6rz5iGe.png" alt=""></p><p>为了解决直线斜率无穷大的问题，我们用另外一种直线的标准式：</p><script type="math/tex; mode=display">x \cos \theta+y \sin \theta=\rho</script><p><img src="https://i.loli.net/2021/10/09/tdZ1nq698TrGY4Q.png" alt=""></p><p>在具体的算法计算上，霍夫变换首先将参数空间划分为多个累加单元。假设其中$(\rho_{min}, \rho_{max})$ 和 $(\theta_{min}, \theta_{max})$ 是期望的参数值范围。坐标 $(i, j)$ 处具有累加值 $A(i,j)$ 的单元对应参数空间 $(\rho_i, \theta_j)$ 的方格。最初，这些单元格被设置为 0，对 $xy$ 平面的非背景点 $(x_k, y_k)$，对于所有可以取的 $\theta$，求得 $\rho$，将该值四舍五入到 $\rho$ 轴上最接近的单元格，若选择一个 $\theta_q$ 的值解得 $\rho_p$，则令：</p><script type="math/tex; mode=display">A(p, q) = A(p, q) + 1</script><p>最后，当 $A(i, j)$ 大于一个特定的值时，认为存在一条对应的直线。</p><h2 id="Metric-Rectification"><a href="#Metric-Rectification" class="headerlink" title="Metric Rectification"></a>Metric Rectification</h2><p>我们需要首先知道 3D 视觉中常见的几种变换</p><ul><li>相似性（<strong>similarity</strong>）变换：由各向同性缩放组成的等距映射</li></ul><script type="math/tex; mode=display">\left(\begin{array}{l}x^{\prime} \\y^{\prime} \\1\end{array}\right)=\left[\begin{array}{ccc}s \cos \theta & -s \sin \theta & t_{x} \\s \sin \theta & s \cos \theta & t_{y} \\0 & 0 & 1\end{array}\right]\left(\begin{array}{l}x \\y \\1\end{array}\right)</script><p>也可以写作矩阵块的形式如：</p><script type="math/tex; mode=display">x^{\prime}=H_{S} x=\left[\begin{array}{ll}s R & t \\0^{T} & 1\end{array}\right] x</script><ul><li>仿射变换（<strong>affine</strong>）变换：保持二维图形的“平直性”，即变换后直线还是直线不会打弯，圆弧还是圆弧和“平行性”，平行线还是平行线，相交直线的交角不变。</li></ul><script type="math/tex; mode=display">x^{\prime}=H_{A} x=\left[\begin{array}{cc}A & t \\0^{T} & 1\end{array}\right] x</script><p>其中 $A$ 是 2×2 的非奇异矩阵。平面仿射变换有6个自由度，对应6个矩阵元素。而它总可以分解为：</p><script type="math/tex; mode=display">A=R(\theta) R(-\phi) D R(\phi)</script><p>其中 $R(\theta)$ 和 $R(\phi)$ 是两个旋转角度，D 是对角矩阵</p><script type="math/tex; mode=display">D=\left[\begin{array}{cc}\lambda_{1} & 0 \\0 & \lambda_{2}\end{array}\right]</script><p>该分解可以通过 SVD 分解实现。</p><ul><li>单应性 （<strong>homography</strong>） 变换：也叫投影变换</li></ul><script type="math/tex; mode=display">x' = H_p x = \begin{bmatrix} A & t\\ V^T & v\end{bmatrix} x</script><p>其中 $v=(v_1,v_2)^T$。</p><p>投影和仿射变换之间的主要区别在于，对于投影变换，向量 $v$ 不为 null，这是投影变换非线性的原因。</p><p>比较理想点 $(x_1,x_2,0)^T$ 在仿射和投影变换下的不同：</p><p>仿射变换：</p><script type="math/tex; mode=display">\left[\begin{array}{cc}A & t \\0^{T} & 1\end{array}\right]\left(\begin{array}{c}x_{1} \\x_{2} \\0\end{array}\right)=\left(\begin{array}{c}A\left(\begin{array}{c}x_{1} \\x_{2}\end{array}\right) \\0\end{array}\right)</script><p>投影变换</p><script type="math/tex; mode=display">\left[\begin{array}{cc}A & t \\V^{T} & v\end{array}\right]\left(\begin{array}{c}x_{1} \\x_{2} \\0\end{array}\right)=\left(\begin{array}{c}A\left(\begin{array}{c}x_{1} \\x_{2}\end{array}\right) \\v_{1} x_{1}+v_{2} x_{2}\end{array}\right)</script><p>在仿射变化中，理想点保持理想状态（即无穷大）。 在投影变换中，它映射到一个有限点。</p><p>要完成图像的度量矫正，我们需要两点：消除投影变换和仿射变换带来的变化</p><p>遵循下面的步骤：</p><ol><li>寻找在图像平面中的平行的点来确定无穷远处的直线表达式。</li><li>由于该线在原本的 3D 坐标系中的无穷远位置移动到了一个有限的位置，我们首先就需要将其回归到无穷远处，即寻找一个变换 $H_p$ 将 $l = (l_1, l_2, l_3)^T$ 变换到 $(0, 0, 1)^T$</li></ol><p>我们一般选择</p><script type="math/tex; mode=display">H_p = \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ -l_1/l_3 & -l_2/l_3 & 1/l_3\end{bmatrix}</script><ol><li>对于图像的每一点应用该变换即可</li></ol><p>这时图像中平行的线就会平行了，下一步需要矫正角度让垂直的线也能垂直。</p><ol><li>首先先选择好在原始场景中互相垂直的线的端点，在图像中选择这些点构成了新的线和新的夹角。</li></ol><p>我们需要计算 $C^{*}_{\infty}$。对于每一组垂直的线，我们有约束，这些约束构成了一个可以解的方程组：</p><script type="math/tex; mode=display">(l_1 m_1, (l_1 m_2 + l_2 m_1) / 2, l_2 m_2, (l_1 m_3 + l_3 m_1) / 2, (l_2 m_3 + l_3 m_2) / 2, l_3 m_3) C = 0</script><ol><li>根据奇异值分解计算可得变换矩阵，对于上一步变换完的结果再乘上该矩阵即可。</li></ol><p>详细过程参考 <a href="https://github.com/YuiCtwo/Learn-DIP">Learn-DIP</a> 中的代码。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Github 的 &lt;code&gt;README.md&lt;/code&gt; 并不支持公式的渲染，所以部分原理讲解的东西移到这个篇章的博客中。&lt;/p&gt;
&lt;p&gt;本篇包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;骨架提取&lt;/li&gt;
&lt;li&gt;霍夫变换&lt;/li&gt;
&lt;li&gt;Canny 边缘检测&lt;/li&gt;
&lt;li&gt;Metric Rectification&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Digital Image Processing" scheme="http://cyx0706.github.io/categories/Digital-Image-Processing/"/>
    
    
    <category term="CV" scheme="http://cyx0706.github.io/tags/CV/"/>
    
    <category term="Digital Image Processing" scheme="http://cyx0706.github.io/tags/Digital-Image-Processing/"/>
    
  </entry>
  
  <entry>
    <title>杂谈：传颂之物</title>
    <link href="http://cyx0706.github.io/2022/02/14/utawarerumono/"/>
    <id>http://cyx0706.github.io/2022/02/14/utawarerumono/</id>
    <published>2022-02-14T12:02:36.000Z</published>
    <updated>2022-07-17T06:36:16.058Z</updated>
    
    <content type="html"><![CDATA[<p>年前一口气把传颂之物三部曲打通关的，感慨颇多。</p><p>我基本不怎么玩 GAL，也没有玩一代的游戏，但补了一代的动漫，想着借寒假的功夫体验一下全部的剧情，就玩了二代：虚伪的假面和三代：二人的白皇。</p><p>玩完好几天都不能平静下来心情，既有失落————一段故事结束了，又有高兴————传颂之物给我带来了一个很棒的故事。</p><p>想写写自己的一点点感想和杂谈。</p><p><strong>！可能会带有大量的剧透，多图警告！</strong></p><p>2022/7/17：随着第三季动漫的播出，看番重温剧情又有了新的理解，果然动的画面就是不一样啊。</p><a id="more"></a><h2 id="剧情">剧情</h2><p>我很喜欢“游记+冒险”式的剧情——在未知的地域邂逅陌生的人，体会不一样的风土人情，结交挚友，攻克难关。每场旅途的结束，有失有得也有成长。整理好心情，向着下一段旅途出发…</p><p>在传颂之物二三的剧本中，我们就随着主角哈克和久远踏入大和，开启了全新的不同于图斯库尔的冒险。</p><p>可以说，二代的剧情的很大一部分都在日常和邂逅上着笔：好吃懒做，梦想是家里蹲的主角哈克，自称哈克监护人的久远，豪爽不拘小节的右近，重情义的军师麻吕吕，怕生的露露缇耶，寻求恋爱的阿图依，毒舌又依赖哥哥的猫音，纯情的Q鲁，好女人（笨蛋）鵟，眯眯眼大哥哥扇（考哥），不知道为什么笑起来总像是坏蛋的御雷，不谙世事顽皮捣蛋的天子杏树，为人严肃武士风范的宗近，带着幼女的剑豪，巫（污）女双子…这些人物在日常中上演欢声笑语的闹剧。</p><p><s>当然还有奥修特尔（替身名：右近，只要我不用奥修特尔的名字乔装成右近和主角团打打闹闹就能保持我高冷的形象）；左近（替身名：御雷，能通过乔装把刺猬头变成光头来让人认不出来）</s></p><p>前期主线剧情上，主角团也就是偶尔打打强盗，做几个任务。大和盛世太平，街市繁华，人民幸福安康。</p><p>随着主线剧情进行过半，哈克记忆恢复，揭开大和的历史，在收线的同时铺开了许多新的疑点。强行和图国开战，圣上被暗杀，奥修特尔被嫁祸，杏树被下毒药。这一切来的太突然了，安宁的日常仿佛还在昨天。战乱开始了。</p><p>武赖决一死战后的奥修特尔用尽了力量，化为尘埃，将假面托付给了哈克。哈克舍弃了自己名字，带上了假面成为了虚假的奥修特尔，对外宣称哈克不幸死亡。二代剧情就在这样的谎言中结束了。</p><p><img src="https://s2.loli.net/2022/02/14/fKRdN78yIeXZE6g.png" alt="右近：接下来就交给你了，小哥"></p><p>相较于二代嘻嘻哈哈悠闲的日常，三代前期日常剧情整体都很低沉。主角团众人都陷在哈克死亡的悲伤中，哈克也在真心和使命的责任之间痛苦。随着扮成奥修特尔的哈克和大家相处时间的增长，也许是时间冲淡了哀伤，也许是在奥修特尔身上看到了哈克的影子，也许是为了大义与国家，停滞的时间又重新流动起来，所有人都看向了明天。随着久远的回归，主角团们重振旗鼓，再次集结在奥修特尔（哈克）身边，一步步着手夺回帝都。</p><p>在这场大乱中，有人为信念而战：武赖为了武人的自尊而战；雷光为了独立，摆脱对帝皇的依赖而战；御雷为了保护人民而战，麻吕吕为复仇和逝去的友人而战。也有人心怀鬼胎。</p><p>与成为伪神的沃西斯一战，目睹了耗尽生命击败沃西斯的哈克消散在面前。久远抑制不住自己的&quot;分身&quot;陷入暴走。而哈克则是<s>被白皇拉起来接着加班</s>接下了白皇的面具，重新出现在大家面前，救出了久远。也因为面具的效果成为了新的神。</p><p><img src="https://s2.loli.net/2022/02/14/ijIuKmQWXZV5nAs.png" alt="为了心爱的久远加班的哈克"></p><p>结局的最后，以哈克奥罗（白皇）的名义，图斯库尔和大和建立起和平的新时代。在后日谈中一行人又踏上了各自的旅途。</p><p><img src="https://s2.loli.net/2022/02/14/qmI6nUOL8pyB19F.png" alt="久远&amp;杏树：以白皇的名义，大和和图斯库尔永世和平!"></p><p>艾露露扶着大白离开了神社，自此一代达成了 Happy End。</p><p><img src="https://s2.loli.net/2022/02/14/3MPo8Ca9hu4IlBs.png" alt="大白：终于可以亲手抱一抱那个孩子了"></p><p>久远也踏上了寻找哈克 <s>（追夫）</s> 的旅行。</p><p>相较于战争场面描写和谋略政治交锋的单薄，三代出色在人物的情感与人际间的情感这种细腻的细节。前期通过日常和主线将女主人公们对于哈克版奥修那种复杂的情感表现的得淋漓尽致。后期帝皇和穗香的感情，哈克与久远的恋情 <s>（你们这对官方CP怎么后期才感情升温啊）</s> 都令人唏嘘不已。</p><p>相较于一代跨越千年的恋情，我觉得二三代更多的是哈克的成长，舍小为大的献身，以及久远与哈克互相拯救的故事。</p><h2 id="人物">人物</h2><p>说说几个我很喜欢的人物和一些感想。</p><h3 id="哈克">哈克</h3><p><s>铁扇恒久远，一锅永流传。</s></p><p>哈克的刻画简直让别的角色都黯然失色。他作为游戏主角喜欢偷懒，耍小聪明，玩世不恭配合藤原叔声线，形象一下子生动了起来。看起来是个烂好人，但总打着自己的小算盘，被久远妈管得服服帖帖。</p><p>从接下面具那一刻，哈克的承担和果断就开始表露，他重情重义，体贴善良和奉献的闪光品德开始显露。哈克对于戴上假面后的责任承担到了最后，直至自己离去。欺骗朋友的自责，欺骗爱人的痛苦，与武赖再战战胜心魔，与御雷信念不同而冲突，哈克不但肉体上承受与强敌战斗的伤痛，内心上更是承受着这些无法言说的痛苦，他不断成长，从不愿工作的家里蹲尼特，变成了治国有方，有勇有谋的总大将，这种反差让他变得更加有魅力。</p><p>哈克几乎承包了我全游戏的泪点，他是那样努力的作为奥修特尔撑起整个主角团，为杏树和恩那卡姆伊带来安全感，帮助猫音走出自责，一步步帮助杏树夺回了大和和皇位。他为了义和责任舍弃了自身，像奥修特尔一样活着。正因为如此，他面对露露缇耶悲伤之情的愧疚，面对奥修特尔母亲时无法诉说内心的挣扎，都让人感到剜心一样痛苦，哪怕一点点关于假扮的事都说不出口。所以当我看到哈克演技露馅的时候，无意间说出真心话的时候，有说不出来高兴和安心，无意间的一句劳动补偿让久远动摇了，也让我的眼眶湿润了。</p><p><img src="https://s2.loli.net/2022/02/14/ZpkM3jKfvdo26Cm.png" alt="奥修母亲：你们都是我自豪的儿子"></p><p>战胜伪神沃西斯之后，假面破碎了，哈克也终于能够卸下包袱。就像右近托付自己时，哈克一脸释然的表情将大和和未来托付给了自己的伙伴们。柔情的 BGM 响起，仿佛快乐的昨天还在过去，离别来的就是那么的突然。能看到这么幸福的哈克我心中的不舍也放下了，哈克，辛苦了。</p><p><img src="https://s2.loli.net/2022/02/14/nktvuIzwGasPL2O.png" alt="哈克：要幸福啊，猫音"></p><p>然鹅哈克最终也没圆了家里蹲的美梦（<s>没能被久远包养</s>），从大白那里继承面具成为新一代解放者，之后踏上了救赎旧人类的旅途。</p><p>在人际关系方面，受某种神秘的力量影响，哈克作为麻吕吕的心之挚友，右近指定继承人，帝皇托付之人，大白钦定的背锅侠，男人缘相当的好（还被剧中人物吐槽过），女人缘这方面也不差。在情感方面，也不是榆木脑袋，明白女孩子们的感情。可惜就是没能有一个完美的 Happy End，物是人非，白阁楼重建了，吵吵闹闹的人们已经不见了。</p><h3 id="久远">久远</h3><p><em>2022/7/17，更新了对久远身份两面性的分析。</em></p><p>曾经艾露露捡回来了失忆的大白，现在久远捡了失忆的小白，官方钦定的 CP，但出于各种原因无法和小白成为眷属，<s>还不是因为二代对待哈克的感情像妈一样，醒悟过来后哈克身边都有一群关系暧昧的妹子了</s>，性格温柔，有时腹黑的大姐姐形象。作为钦定女主其实和哈克的二人戏并不多，也只有三部夺回帝都之后度蜜月去了。明明身手不凡，办事稳重，又会各种技艺，很有安全感，但两次因为哈克的死讯失控，第一次被亲人的爱拯救，第二次被众人的爱，小白的爱拯救。</p><p>作为图国公主和药草师，两个身份在剧情表现上有很大的割裂感。</p><p>在二代的剧情中，作为身份神秘，成熟稳重的旅行的少女与哈克结识。像管儿子已经管理着哈克，严肃起来像极了艾露露。在大和侵略图国的时候出于对朋友的考虑帮助了大和打了自己人。这一行为或多或少是抱着玩一玩的心态，也是久远内心明白大和侵略军是打不过的图斯库尔的一种表现吧，在开仗前还劝宗近不要和贝纳威交手。这一个在二代充满争议的行为在我看来更多想表达的是她对自己身份认识的不成熟和孩子气。万幸图国人均久控，溺爱久远，没有谁指出来了这一问题。</p><p><img src="https://s2.loli.net/2022/02/14/DXu7OG5LAaj3fSv.png" alt="哈克什么也没有说，只是把扇子递给了久远"></p><p>在二代结局因为假奥修告知小白的死无法接受而与主角团离别，暴走失去记忆。在图斯库尔回忆起后想和同伴团聚却逃不出自己的身世带来的责任，以皇女的身份向大和宣战，自认为是拯救大和的唯一道路。坚持着就算受到同伴的质疑和不理解也要这么做的“自我牺牲”。在感受到了杏树的坚强和认出哈克的伪装后动摇了，舍弃了自己皇女的面具重新回归了主角团。这一出“刀子嘴，豆腐心”的会面，是表现出了她对同伴们的感情，但也让之前她对皇女身份责任的觉悟显得廉价与单薄，看起来皇女的身份就像是个挂设，时不时拿出来圆圆剧情。想要站在大和的立场上帮助自己的同伴，久远注定与自己的命运对抗，不应该是剧情中表现出来的“认出来了小白”，“感受到了杏树的坚强”，也不应该是克罗和贝纳威溺爱的给了久远溜走的台阶。</p><p>在帝都夺回前的剧情几乎就没有以皇女身份再登场了，回到了那个和大家吵吵闹闹的药草师久远。完全没看出来和过去的诀别好吧！不过不以这么严肃的视角来看，久远就是一个可爱，外表坚强但内心脆弱的女孩子，我磕爆久远哈克 cp 好吗！</p><p><img src="https://s2.loli.net/2022/02/14/7fkQtr3bGSE9l4c.png" alt="久远：这次不会再让你逃跑了~"></p><h3 id="露露缇耶">露露缇耶</h3><p>最开始露露缇耶给我带来的印象是怕生的公主，大家闺秀，有些许自卑，害怕自己排不上用场，<s>腐女</s>，也是二代明显对哈克表露出好感的少女。她看起来那么纯真可爱，小心翼翼的隐藏着自己的感情，既怕被发现，有会因为心上人的小小举动感到幸福。在得知哈克离世的噩耗后一蹶不振，<s>未婚先寡</s>。她只是一心思念哈克而悲伤，后悔着自己的软弱。而她在假奥修身上看到了哈克的影子，因为害怕现在没有做的事情以后就没有机会了而迷茫中。在去过九重里之后，露露缇耶变得坚强起来，她不再沉浸在悲伤中，而是要像哈克一样守护伙伴们与归宿，后来在发现假奥修的真身后，再次唤醒了心底的恋情。安心，不甘，她害怕连身为奥修的哈克也失去，把对哈克的爱埋藏起来，等待哈克归来的那一天。无论是哈克消失前的临别还是在后日谈中，都坚定的相信哈克会归来。也许她的恋情永远没有结果，但她还是不渝的爱着哈克。做得一手好饭，泡得一手好茶，温柔体贴，忠贞不渝，简直是大和抚子形象的少女。<s>我要看哈克和露露小公主唧唧我我啊！！</s></p><p><img src="https://s2.loli.net/2022/02/14/SuvpzQKLRjid2OH.png" alt="眺望故乡&amp;不再迷茫的小公主"></p><h3 id="阿图依">阿图依</h3><p>说话带着口音，带着奇怪的水母宠物，对战斗有着痴迷的热情和病娇一样的笑声，阿图依有着很多明显的人设。二代中未战先输，见面的时候直言哈克从后面看起来很帅，但正面就很残念。谈恋爱失败了和哈克一起喝酒，借酒消愁，和哈克完全是心知友的关系，也有些许好感。在三代一开始也是看起来对哈克的死讯最没有触动的角色。但随着纳卡库的皇子到来，有了一个爱着自己的人，才渐渐对假奥修产生感情。归来时月夜的船上，由假奥修的一句话“像往常一样陪你喝到天亮”认出了哈克，两份感情重叠到了一起，才意识到自己已经喜欢上哈克了。。</p><p><img src="https://s2.loli.net/2022/02/14/MqJ685VHfU7WXGj.png" alt="阿图依：海神大人是不是也很专一呢~"></p><h3 id="猫音">猫音</h3><p>二三代最苦命的角色。二代最后，由于自己的原因最爱的哥哥死了；三代中，替代自己哥哥的哈克也离去了，同样的方式，说着同样的话（要幸福啊…猫音）离开了自己。在三代剧情的最开始，深陷害死自己哥哥的自责，随着小白的成长，慢慢的将兄长的身影和小白重合，为了哥哥的遗愿，猫音好不容易才从崩溃走出来，但又要面对的是哈克的离去。所幸哈克的归来给了猫音鼓励，留下了希望，在后日谈中，我们才能看到坚强的猫音，考上学士，在家乡等待着哈克的归来。</p><p><img src="https://s2.loli.net/2022/02/14/EkP9aUQVjZwS15r.png" alt="哈克：回去吧，大家都在等待着的"></p><h3 id="其他">其他</h3><p>杏树二代看起来还是弱女子，三代挥舞卡姐的大剑呼呼生风。在二代，偷溜出皇宫，偷吃各种熊孩子行为，三代中认识到自己的无力和弱小，不甘于作为花瓶，以战士的身份在第一线战斗。可以说是二三代变化最大的角色了。不喜欢死板的规矩，很怕宗近，视久远为“宿敌”（对哈克的情感上和作为皇女的身份上），经常和久远争夺哈克。经历了苦难，没有了稚气，展现出来作为统治者身份的自觉和承担，在后日谈中周游诸国斩奸除恶 <s>（其实只是想玩吧！）</s></p><p>沃西斯作为幕后大 Boss，完全没有武赖的霸气和雷光的偏执，反而滑稽可笑。剧情后期很赶，各种强行便当，各种强行打不过，憋一肚子气，沃西斯又那么自私，傲慢自满，他最后吃瘪我只能说该，我也不接受洗白。</p><p>麻吕吕的剧情我都觉得挺遗憾的。麻吕吕摆脱洗脑控制，醒悟过来后为哈克挡刀直接领便当下班了，虽然他作为反派的时候鲨人放火，但我希望能给他以更飒爽的方式离去，比如说与哈克一对一对决后受重伤而醒悟，为了赎罪而选择离开人世，最后在哈克怀中安详离去。</p><p>与御雷打了四五次后，总算是承认了哈克作为奥修特尔的继承者了，之后便被沃西斯暗杀受重伤，差点领了便当。后面的战斗可以选择御雷参与了，但难得左右卫大将齐聚，没有哈克和御雷的协击必杀，也没有二者的高达一起出场的战斗，少了点令人振奋的场面。</p><h2 id="写在后面">写在后面</h2><blockquote><p>“传颂之物第三部能够给我们带来什么吗？”<br>“兽耳娘和尾巴。”<br>“你误会我了伙计，我说的是这作游戏的最终价值，归根结底，这作游戏能给我们带来什么？”<br>“超赞兽耳娘和尾巴。”</p></blockquote><p>玩完的时候有千言万语，玩完感慨万千，写的时候就只能寥寥几字。诚然传颂之物三部曲并不完美，剧情上也有很多漏洞，三代作为全篇的高潮篇章，最后与沃西斯的剧情也有些仓促，一些建立在人物不合理举动上的剧情有些突兀，但这不妨碍它讲出了一篇完整的感人的好故事。</p><p>受传颂者，<br>是被亚人们尊称为“伟大之父”的旧人类，化为了没有意识不老不死的怪物。因为贪婪触碰了禁忌的力量，到头来落得如此下场。<br>是哈克奥罗这个名字，大白小白伟大的事迹，代代口口相传，就如同这些故事一样流传后世。<br>也是人们心底最纯真的善与初心，奔波于岁月长河中的人，命运不一，也许他们不曾找回太古的记忆，但仍不会忘记初心，仍不会忘记善良与仁爱的本心。</p><p>故事的主人公们踏上了新的旅途，收拾好行囊和情感，怀揣着希望迈向未来，我们何尝不应该也这样呢？我们的时间不能永远的停滞在昨天，要乐观并抱着希望走向明天。</p><p><img src="https://s2.loli.net/2022/02/14/XyPvMJaKiB8NTq9.png" alt="哈克：扇子我借走用一下啦~"></p><p><s>可恶，这个男人为什么这么帅！</s></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;年前一口气把传颂之物三部曲打通关的，感慨颇多。&lt;/p&gt;
&lt;p&gt;我基本不怎么玩 GAL，也没有玩一代的游戏，但补了一代的动漫，想着借寒假的功夫体验一下全部的剧情，就玩了二代：虚伪的假面和三代：二人的白皇。&lt;/p&gt;
&lt;p&gt;玩完好几天都不能平静下来心情，既有失落————一段故事结束了，又有高兴————传颂之物给我带来了一个很棒的故事。&lt;/p&gt;
&lt;p&gt;想写写自己的一点点感想和杂谈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;！可能会带有大量的剧透，多图警告！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2022/7/17：随着第三季动漫的播出，看番重温剧情又有了新的理解，果然动的画面就是不一样啊。&lt;/p&gt;</summary>
    
    
    
    <category term="CommentOn" scheme="http://cyx0706.github.io/categories/CommentOn/"/>
    
    
    <category term="essay" scheme="http://cyx0706.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>2022</title>
    <link href="http://cyx0706.github.io/2022/01/03/welcome-2022/"/>
    <id>http://cyx0706.github.io/2022/01/03/welcome-2022/</id>
    <published>2022-01-03T06:53:56.000Z</published>
    <updated>2022-01-03T09:01:15.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2021：机会与麻烦并存">2021：机会与麻烦并存</h2><p>2021 年飞逝，转眼已经到了新的一年。我也如愿以偿的打出了 “A 结局：保研”。</p><a id="more"></a><p>就像 RPG 游戏中固定回合数/时间触发的事件一样，在 2021 的大部分时间里，我都在奔波于名为“寻找保研学校”的主线任务中：联系导师后根据个人的状态数值，有机会触发考核事件。到了6月7月，各大高校的夏令营活动举行，表现优异者能拿到专属道具：“xx 学校的 Offer”。</p><p>这几个回合我是怎么过的，可以看 <a href="https://cyx0706.github.io/2021/08/07/naikai-uni/">某某大学旅游指南</a>。称不上是攻略，但算得上是初见流程。不得不说，对于我这种末流 985，无论文无高含金量的奖项的人来说，简直就是地狱难度。能坚持到最后并找到了心仪的组，我还是挺欣慰的。</p><p>大家都不想考研和找工作，所以挤破头冲保研。短短的两个月左右，我校在某乎“如何评价”话题中夺得两筹：先是“海洋哥”，不对，纯 Rank 选手“复旦哥”激起层层水花，再到保研成绩计算时的替课风波，几家欢喜几家愁。我看了个爽，高呼精彩。</p><p>保研系统按下确认的按钮后，我以为美好的未来就要开始了，鱼还没摸上几天就被赶着去实习。慧与班的工程实习 II 如同达摩克斯之剑悬在头顶。去？便是身不由己，不情愿打工；不去？那就是推拖到下学期，耽误时间（事实上，对考研人实习的要求，也就是下学期完成这门课，轻松了好多）。学校前手要求线下实习，后手就安排下学期线上；前手刚安排了一部分实习，后面直接加个人找实习的要求。我只能说真是折磨。</p><p>我没有毅然决然的骨气，便从了学校安排的实习，自此白天努力增删改查，晚上听另外一批人讲他们那边怎么轻松怎么轻松，心里还惦记着给研究生阶段的学习打基础。<a href="https://cyx0706.github.io/2021/11/15/work-work/">打工人的生活苦乐酸甜</a>，算是扩展了人生阅历吧。在项目差不多结束的时候草草收尾跑路（12.31）。新的一年，我要把时间都用在自己的计划上。</p><h2 id="你好，2022">你好，2022</h2><p>现在想想，保研结束后也没做太多的事情：</p><ul><li>呼吁我身边的同学公开课程实验，并将他们收集到了一起<a href="https://github.com/ITStudioOUC/awesome-ouc-cs">awsome-ouc-cs</a></li><li>拟定了爱特程序部项目规范，并完成了一些基于该规范的 Django 工具类和函数 <a href="https://github.com/ITStudioOUC/Django-API-Utils">Django-API-Utils</a></li><li>写了些博客，为自己整理的 <a href="https://github.com/cyx0706/Learn-DIP">Learn-DIP</a> 仓库贡献了更多的代码。</li><li>研究生基础要打的，学习完了 CS 131 并完成了大部分的实验，CS 231n 只看了看讲义，CS 231a 也只看了讲义。</li></ul><p>大四上一个学期啊，整整一个学期，基本就干了这么点事，虽说实习耗费了很多的精力，但本质上还是养老摸鱼的一个学期。</p><p>我身边的同学有人天天摸鱼拿着 300+ 的实习日薪，也有早早开始毕设，日程拉满的。自己宁肯达不到学校要求的工时也要脱离实习，真正离开后发现又没有太多自己想做的事情。2021 的最后一天晚上，我在想什么是人生理想，人生目标，什么是精神充实，怎样释放压力。我发现，这一年来太忙了，以至于对于这段空闲期过得提心吊胆的。我想起父母告诉我的学会生活，到头来自己还是被别人牵着走，想让自己和别人在相近的高度开始下一阶段的竞争。</p><p>去寻找吧，只要还有时间，拾起来兴趣，看看书，过慢生活，不用着急着和别人比较，保持好自己的节奏，自己付出 3 年努力换来的，为什么不能自己随心所欲的使用呢？</p><p>后续时间里，也就是寒假，我要：</p><ul><li>继续更新 Learn-DIP 仓库中的代码</li><li>看文学作品，看小说</li><li>做 CS 231a， CS 231n 的实验，一定要做</li><li>写写博客，记录知识</li><li>写毕设开题报告，读论文写综述，跑跑实验</li><li>背单词，锻炼身体（之前总是坚持一段时间就断了）</li></ul><p>2022 也许会更好，毕竟一切才刚刚开始。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;2021：机会与麻烦并存&quot;&gt;2021：机会与麻烦并存&lt;/h2&gt;
&lt;p&gt;2021 年飞逝，转眼已经到了新的一年。我也如愿以偿的打出了 “A 结局：保研”。&lt;/p&gt;</summary>
    
    
    
    
    <category term="essay" scheme="http://cyx0706.github.io/tags/essay/"/>
    
  </entry>
  
  <entry>
    <title>早安！打工人</title>
    <link href="http://cyx0706.github.io/2021/11/15/work-work/"/>
    <id>http://cyx0706.github.io/2021/11/15/work-work/</id>
    <published>2021-11-15T01:04:48.000Z</published>
    <updated>2021-12-03T09:44:21.025Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于我突然要打工这件事">关于我突然要打工这件事</h2><p>众所周知，在皇家美羊大学计算机系，哦不，应该是计算机学部，慧与班是对于转专业的福利最好的班级了：</p><ul><li>专业课必定可以选中，指年年没有优先级等加课</li><li>实行导师制，大一选定导师可以给你指导，指“可以”指导</li></ul><p>等等，好处竟然有这么多！那么，代价是什么呢！？</p><a id="more"></a><blockquote><p>慧与班大四必须参加统一学校安排的实习，即培养方案中的 工程实习II 对于慧与班来说是必修。</p></blockquote><p>受到疫情影响，统一安排指不上了，就改成了可以各自找实习，学校也会找一些实习，也可以参加学校统一安排的实习。</p><p>然后开了腾讯会议说明了实习的相关事项，结束的时候我问：“可以去导师实验室实习吗？”</p><p>我得到的回复是 “工程实习，那肯定要去企业啊！”，没啥问题，确实是，那就去呗。</p><p>个人懒得自己折腾文件，就服从学校安排找了个实习，我前手刚面试完，就听说 XX 同学要去导师那里打工了。</p><p>“你不弄实习的吗？”，“啊，我给老师说过了，我去高校实习。”</p><p>en？好家伙，真就明文规定是明文，私下咋样都行是吧，欺负老实人是吧！</p><p>虽然这种管理我听我爸说的多了去了，毕竟这样才显得“讲道理”对吧，</p><blockquote><p>啊，没时间不想去，反正都要干活去导师那里不一样吗？</p></blockquote><p>我就干认倒霉呗，反正我这学期还有课，想去也没法去。</p><p>所以从大概 9 号开始，我正式成为一个打工人，可喜可贺，隔壁 AiDai 听了工资都说“我接活一天挣的都比你多”。</p><p>反正我不怎么关心钱，干满学校要求的工时就跑路，来涨涨见识也不错。</p><p><img src="https://i.loli.net/2021/11/15/R7tCWEjlwJnVHPU.jpg" alt=""></p><p><s>然后就被迫三天速成 SpringBoot 拉去干业务</s></p><h2 id="拖更说明">拖更说明</h2><p>就在我折腾实习这事的时候，竟然有两个人 star 了我的 Learn-DIP 仓库！！！</p><p>平生第一次不是课内作业得到了 star，给我了继续完善下去的动力，虽然最近疯狂鸽，CS 131 hw5,6,7 还没做，CS231n 还没看，这学期的目标就定为这些学完，写完。</p><p>这段时间接的导师给的翻译论文的任务，也挺累的，但学到了好多新的东西，state-of-art的技术和方法，改日统统写成博客。</p><h2 id="追加">追加</h2><p>// 2021.12.03:</p><p>光速定了毕设题目，和 3 维重建相关的，好家伙 CS231n 还没看一点 CS231a 就要开始学了。</p><p>太忙了 <s>最近 Steam 10h+ 的 KindomRush: Origin 你好意思吗</s></p><p>还没从保研完那会的摸鱼状态调整回来，最近调整下状态…</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;关于我突然要打工这件事&quot;&gt;关于我突然要打工这件事&lt;/h2&gt;
&lt;p&gt;众所周知，在皇家美羊大学计算机系，哦不，应该是计算机学部，慧与班是对于转专业的福利最好的班级了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;专业课必定可以选中，指年年没有优先级等加课&lt;/li&gt;
&lt;li&gt;实行导师制，大一选定导师可以给你指导，指“可以”指导&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等等，好处竟然有这么多！那么，代价是什么呢！？&lt;/p&gt;</summary>
    
    
    
    
    <category term="essay" scheme="http://cyx0706.github.io/tags/essay/"/>
    
  </entry>
  
</feed>
